"""Read a Detailed CSV Report generated by Markus and a classlist file
generated by Blackboard, and print the corresponding gf file to stdout.
"""

import argparse
import sys
import csv
import datetime
import io


MARKUS_MULT_CONST = 1.0  # Multiply by this const to get the grade on MarkUs.
                         # can't figure out why it should sometimes be 1 and
                         # sometimes 4 ?!


def make_gf(classlist, markus_file):
    """(file reader, file reader) -> (str, str)

    Given two file readers, one for the claslist file from Blackboard,
    and one for the MarkUs grades file, return a pair (header, body)
    for the gf file.

    """

    students = load_students(classlist)
    marks = load_marks(markus_file)
    check_input(students, marks)

    markus_file.seek(0)
    header = make_gf_header(markus_file.readline())
    body = make_gf_body(students, marks)

    return (header, body)    


def make_gf_header(line):
    """Return a header for a gf file from the given line of a MarkUs file.
    """

    header = ('*/,\n' +
              '*Grades file generated by markus2gf on %s' % 
              datetime.datetime.today() + '\n'
              'utorid " ! , 9\n')

    (student_id, marks, out_ofs) = _check_and_parse_line(line)

    for i in range(len(out_ofs)):
        header += 'm%s / %s\n' % (i, out_ofs[i])

    return header


def make_gf_body(students, all_marks):
    """({str: Student}, {str: [float]}) -> str

    Return a body for a gf file given two dicts, of students and marks.

    """

    body = ''

    for (student_id, st) in students.items():

        try:
            marks = all_marks[student_id]
        except KeyError:
            print('Warning: no record for student %s in the MarkUs file' %
                  student_id,
                  file=sys.stderr)
            marks = []

        body += ('%s    %s %s,%s,' % 
                 (st.student_number, st.last, st.first, student_id) +
                 ','.join(list(map(str, marks))) +
                 '\n')
    return body


def load_marks(markus_file):
    """(file reader) -> {str: [float]}

    Given a file reader for the MarkUs file, return a dict that maps
    student_id to a list of grades.

    """

    all_marks = {}
    for line in markus_file:
        (student_id, marks, out_ofs) = _check_and_parse_line(line)
        all_marks[student_id] = marks
    return all_marks


def _check_and_parse_line(line):
    """(str) -> (str, [float], [float])

    Given a line from a MarkUs file, return a tuple of a str and two
    lists of floats (student_id, marks, out_ofs). In case of an
    invalid line, print an error message to stderr and return [] in
    place of a list (or both lists) that could not be produced.

    """

    parsed = next(csv.reader(io.StringIO(line)))
    marks_list = parsed[2:-3]

    if len(parsed) < 5 or len(marks_list) % 2 != 0:
        print('Ill-formatted MarkUs line: %s' % line, file=sys.stderr)
        return ('', [], [])

    if marks_list == []:
        print('Warning: no marks from line %s' % line)

    student_id = parsed[0]

    marks = []
    for i in range(0, len(marks_list), 2):
        if marks_list[i] == '':
            marks.append(0)
            continue
        try:
            marks.append(float(marks_list[i]))
        except ValueError:
            print('Non-number and non-"" mark on MarkUs line: %s' % line, 
                  file=sys.stderr)
            marks = []
            break

    out_ofs = []
    for i in range(1, len(marks_list), 2):
        try:
            out_ofs.append(float(marks_list[i]) * MARKUS_MULT_CONST)
        except ValueError:
            print('Non-number out-of value on MarkUs line: %s' % line,
                  file=sys.stderr)
            out_ofs = []
            break

    return (student_id, marks, out_ofs)


def check_input(students, marks):
    """({str: Student}, {str: [float]}) -> NoneType

    Report to stderr if there are any records in the MarkUs file with
    no corresponding records in the classlist file.
    """

    for student in marks:
        if student not in students:
            print(('Warning: no record of %s in classlist file, ' +
                   'but marks present in Marks file.') % student,
                  file=sys.stderr)


def load_students(student_file, skip_header=True):
    """Given student_file, a file reader for a file in the format
       student_id,first,last,student_number,email
    load all Students in this file into a dict.
    Returns a {student_id: Student} dict.
    """
    
    students = {}

    if skip_header:
        next(student_file)

    for line in student_file:
        try:
            student = Student(line)
            students[student.student_id] = student
        except ValueError:
            print('Warning: could not create Student from %s' % line,
                  file=sys.stderr)
            continue

    return students


class Student:
    """A representation of a student.
    """

    def __init__(self, line):
        """Instantiate this Student from a line in BlackBoard generated
        csv student file:
        student_id,first,last,student_number,email

        """

        [self.student_id, self.first, self.last,
         self.student_number, self.email] = next(csv.reader(io.StringIO(line)))
        self.student_number = self.student_number.zfill(10)

    def __str__(self):
        return self.student_id

    
if __name__ == '__main__':

    # get args
    parser = argparse.ArgumentParser(
        description=('Read a Detailed CSV Report generated by Markus and a '
                     'classlist file generated by Blackboard, and output the '
                     'corresponding gf file, in CDF Grades format.'))
    parser.add_argument('markus_file',
                        help='Path to the Detailed CSV Report from Markus')
    parser.add_argument('classlist',
                        help=('Path to the classlist file from Blackboard in ' + 
                              'format\n\tutorid,first,last,student_number,email'))
    args = parser.parse_args()

    # open input files
    try:
        classlist = open(args.classlist)
    except IOError as error:
        print('Cannot open classlist file: %s' % error, file=sys.stderr)
        exit(1)

    try:
        markus_file = open(args.markus_file)
    except IOError as error:
        print('Cannot open MarkUs file: %s' % error, file=sys.stderr)
        exit(1)

    (header, body) = make_gf(classlist, markus_file)
    classlist.close()
    markus_file.close()
    
    print(header + '\n' + body, end='')
